import { useState, useCallback, useEffect, useRef } from 'react';
import type { OhmBoard, OhmCard, ColumnStatus } from '../types/board';
import { STATUS } from '../types/board';
import { loadFromLocal, saveToLocal } from '../utils/storage';
import {
  createCard,
  moveCard,
  addCardToBoard,
  updateCardInBoard,
  removeCardFromBoard,
} from '../utils/board-utils';

/** Debounce save to avoid excessive writes */
function useDebouncedSave(board: OhmBoard, delayMs = 500) {
  const timeoutRef = useRef<ReturnType<typeof setTimeout>>(undefined);

  useEffect(() => {
    timeoutRef.current = setTimeout(() => {
      saveToLocal(board);
    }, delayMs);
    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    };
  }, [board, delayMs]);
}

export function useBoard() {
  const [board, setBoard] = useState<OhmBoard>(() => loadFromLocal());

  // Auto-save on changes
  useDebouncedSave(board);

  /** Quick-add a card to Charging (minimal friction, optional details) */
  const quickAdd = useCallback(
    (
      title: string,
      overrides?: Partial<Pick<OhmCard, 'description' | 'energy' | 'category' | 'nextStep'>>,
    ) => {
      const card = createCard(title, overrides);
      setBoard((prev) => addCardToBoard(prev, card));
      return card;
    },
    [],
  );

  /** Move a card to a new status */
  const move = useCallback((cardId: string, newStatus: ColumnStatus, whereILeftOff?: string) => {
    setBoard((prev) => {
      const card = prev.cards.find((c) => c.id === cardId);
      if (!card) return prev;
      const updated = moveCard(card, newStatus, whereILeftOff);
      return updateCardInBoard(prev, updated);
    });
  }, []);

  /** Update any card fields */
  const updateCard = useCallback((updatedCard: OhmCard) => {
    setBoard((prev) => updateCardInBoard(prev, updatedCard));
  }, []);

  /** Delete a card */
  const deleteCard = useCallback((cardId: string) => {
    setBoard((prev) => removeCardFromBoard(prev, cardId));
  }, []);

  /** Reorder a card within a column */
  const reorder = useCallback((cardId: string, newSortOrder: number) => {
    setBoard((prev) => {
      const card = prev.cards.find((c) => c.id === cardId);
      if (!card) return prev;
      return updateCardInBoard(prev, {
        ...card,
        sortOrder: newSortOrder,
        updatedAt: new Date().toISOString(),
      });
    });
  }, []);

  /** Reorder multiple cards at once (assign sequential sort orders) */
  const reorderBatch = useCallback((orderedIds: string[], draggedId: string) => {
    setBoard((prev) => {
      const now = new Date().toISOString();
      return {
        ...prev,
        cards: prev.cards.map((c) => {
          const newIndex = orderedIds.indexOf(c.id);
          if (newIndex === -1) return c;
          return {
            ...c,
            sortOrder: newIndex,
            updatedAt: c.id === draggedId ? now : c.updatedAt,
          };
        }),
        lastSaved: now,
      };
    });
  }, []);

  /** Update column capacity (energy segments) */
  const setCapacity = useCallback((status: ColumnStatus, capacity: number) => {
    const field =
      status === STATUS.CHARGING
        ? 'chargingCapacity'
        : status === STATUS.LIVE
          ? 'liveCapacity'
          : status === STATUS.GROUNDED
            ? 'groundedCapacity'
            : null;
    if (!field) return;
    setBoard((prev) => ({ ...prev, [field]: capacity, lastSaved: new Date().toISOString() }));
  }, []);

  /** Add a category to the board */
  const addCategory = useCallback((category: string) => {
    setBoard((prev) => {
      if (prev.categories.includes(category)) return prev;
      return {
        ...prev,
        categories: [...prev.categories, category],
        lastSaved: new Date().toISOString(),
      };
    });
  }, []);

  /** Remove a category from the board and clear it from any cards using it */
  const removeCategory = useCallback((category: string) => {
    setBoard((prev) => {
      if (!prev.categories.includes(category)) return prev;
      return {
        ...prev,
        categories: prev.categories.filter((c) => c !== category),
        cards: prev.cards.map((card) =>
          card.category === category
            ? { ...card, category: '', updatedAt: new Date().toISOString() }
            : card,
        ),
        lastSaved: new Date().toISOString(),
      };
    });
  }, []);

  /** Replace the entire board (used by Drive sync when remote is newer) */
  const replaceBoard = useCallback((newBoard: OhmBoard) => {
    setBoard(newBoard);
    saveToLocal(newBoard);
  }, []);

  return {
    board,
    quickAdd,
    move,
    updateCard,
    deleteCard,
    reorder,
    reorderBatch,
    setCapacity,
    addCategory,
    removeCategory,
    replaceBoard,
  };
}
